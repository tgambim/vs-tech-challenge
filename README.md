# Decisions

I've decided to break the project into two parts: 
- create a small framework to handle requests, routing and objects initialization
- implementing the api with all business logic

I also avoided using any libraries/frameworks to demonstrate as much as possible my skills and decisions. The exceptions
were the Jackson lib for converting objects to/from JSON, the Reflections lib that were used for scanning classes with annotations
and JUnit/Mockito that help writing tests.

## Framework
### Routing
Here I opted to do annotation based routing system to handle all the requests. Doing that I could extract all the logic 
from the application to the framework implementation and making easier to find which route is handled by the methods. 
Also, with this implementation it is really simple to create new controllers. To do routing you have to:
- Have a class annotated with @Controller, informing the base path of that REST controller
- Have a method inside that controller annotated with @RequestMapping and declaring the request method. You can also inform 
a complementary path that is concatenated with the controller base path
- To add query params you should create method parameters annotated with @QueryParam, passing the name of the parameter and if it is optional
- To add a request body you should create a method parameter annotated with @Body
- To send a custom success http status code you can annotate the method with @ResponseStatus using the desired code as parameter

### DI
I decided to use a simple dependency injection to make the code more flexible and easier to test. Doing that I could mock all the 
dependencies and isolate the tests of each component. To implement that I've created the  [ApplicationContainer](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fcontainer%2FApplicationContainer.java)
class that handle all the object instances orchestration. I've also implemented the application in a way that all the classes 
annotated with @Controller or @Component were instantiated by the container. Doing that was simple to build all the application layers.

### Authentication
To make the authentication generic and easy to implement, I've created the [AuthenticationService](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fsecurity%2FAuthenticationService.java) 
interface. To use the authentication you should: 
- Create an implementation of the Service and annotate that with @Component to be created in the ApplicationContainer
- Annotated the controller methods that should the authenticated with @Authenticated

Doing that I could reuse the authentication in all endpoints, and it was easy to add auth to then. Also, if the authentication
need to change, its only necessary to change the AuthenticationService implementation.

### Data
To store all the data I've created a [InMemoryRepository](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fdata%2FInMemoryRepository.java) 
class with all the basic operations I needed: list, find and save. All the data was stored in a HashMap using the entity 
id as key. I did that to improve the performance of the find by id operations since the HashMap provides constant time to get operations.
Also, the InMemoryRepository implements the [Repository](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fdata%2FRepository.java) interface
so, with its necessary to replace the InMemoryRepository with a database it should be simple as long as the new DatabaseRepository
implements the RepositoryInterface

The InMemoryRepository can store any class that extends the Entity class. I implemented it that way to reuse the repository
to all models and also ensure that all the stored models have an id.

I've also built a [FileSeeder](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fdata%2FFileSeeder.java) that can be used
to seed data from a json file to a repository. It was build using Generics and some inversion of control to be reusable 
for any model and its respective repository

### Exceptions
I've created multiple exceptions to handle errors in the application:
- [AuthenticationException](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fexception%2FAuthenticationException.java) handles authentication errors
- [InvalidRequestException.java](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fexception%2FInvalidRequestException.java) handle errors in the request payload/params
- [NotFoundException.java](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fexception%2FNotFoundException.java) handle routes and resource not found errors
- [ValidationException.java](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fexception%2FValidationException.java) handle the validation of models being created/updated

All these four exceptions are API exceptions and results in 4xx status codes, according to the exception. To handle exceptions
generated by the server code I've created the [InternalException.java](src%2Fmain%2Fjava%2Fcom%2Fgambim%2Fframework%2Fexception%2FInternalException.java).
This exception results in a 500 status code an "Internal server error." message.


## Product
Here I've created a few layers to handle the incoming request, manipulate data and store it:

- controller:  create all the routes and map then to service methods.
- service: responsible for all the business logic
- repository: store all the data
- entity: responsible for modeling the data stored in the repositories 
- DTO: responsible for modeling the data received and sent in the controllers
- converter: convert data between entities and DTOs
- validation: validate the DTOs before creating/updating
- seeder: populate data in the application when it starts

# Improvements
As the intent of this implementation was to show my coding skills I avoid using libs but a big improvement would be to use
some libraries to reduce boilerplate like Project Lombok that automatically generates getters, setter, constructors, among other
things using annotations. Apache Commons could also be used to improve URI and parameter parsing.

The Application container could also be improved providing a way to easily override components to give more flexibility to the framework.
It would also be nice to have a way to configure methods that return objects that should be added to the container. With this
would be easier to add objects the need some kind of configuration, like the Jackson ObjectMapper that needs to register modules.
Another option is to use a more robust framework like Spring Boot to have more options while expanding the api.

The authentication credentials shouldn't be fixed and hardcoded. It's a better option to remove then from the repository and
start using some credential service like AWS Secrets Manager or AWS Parameter Store.

About the product itself, creating controllers to manage Locations and ServiceCategories is probably a necessary step to build 
the application.

If the goal is to deploy the application in AWS, a good option is to create the infrastructure using AWS CDK.

# API documentation

### Potential vendors for a given job:
Request:
``` http request
GET http://localhost:8000/api/vendors?jobId={jobId}

Headers:
Authorization: Basic {token}
```
where {jobId} should be the job id you want to list the vendors for and {token} is the basic authentication token

Response:
``` json
[{
    "id": 3,
    "name": "vendor 3",
    "location": {
        "id": 10,
        "name": "Fayette",
        "state": "TX"
    },
    "serviceCategories": [{
        "id": 2,
        "name": "Air Conditioning",
        "compliant": true
    }]
}]
```

### Vendors count for a given location and service category:
Request:
``` http request
GET http://localhost:8000/api/vendors/count?locationId={locationId}&serviceCategoryId={serviceCategoryId}
```
where {locationId} and {serviceCategoryId} should be the location id and service category id, respectively, 
that you want to list the vendors for.

Response:
``` json
{
    "totalCount": 3,
    "compliantCount": 1,
    "notCompliantCount": 2
}
```

### Create vendor:
Request:
``` http request
POST http://localhost:8000/api/vendors

Headers:
Authorization: Basic {token}

Body
{
    "name": "{vendorName}",
    "locationId": {locationId},
    "services": {
        "{serviceCategoryId1}": {compliant1},
        "{serviceCategoryId2}": {compliant2}
    }
}
```
where: 
- {vendorName} is the vendor name
- {locationId} is the location id
- services is a map where {serviceCategoryIdX} is a service category and {compliantX} is the compliant status (true/false) for that category
- {token} is the basic authentication token

Response:
``` json
{
    "id": 6,
    "name": "vendor 6",
    "location": {
        "id": 1,
        "name": "Glades",
        "state": "FL"
    },
    "serviceCategories": [
        {
            "id": 2,
            "name": "Air Conditioning",
            "compliant": true
        },
        {
            "id": 4,
            "name": "Landscaping Maintenance",
            "compliant": true
        }
    ]
}
```

### Create Job:
Request:
``` http request
POST http://localhost:8000/api/jobs

Headers:
Authorization: Basic {token}

Body
{
    "description": "{jobDescription}",
    "locationId": {locationId},
    "serviceCategoryId": {serviceCategoryId}
}
```
where:
- {jobDescription} is the job description
- {locationId} is the location id
- {serviceCategoryId} is the service category id
- {token} is the basic authentication token

Response:
``` json
{
    "id": 6,
    "name": "vendor 6",
    "location": {
        "id": 1,
        "name": "Glades",
        "state": "FL"
    },
    "serviceCategories": [
        {
            "id": 2,
            "name": "Air Conditioning",
            "compliant": true
        },
        {
            "id": 4,
            "name": "Landscaping Maintenance",
            "compliant": true
        }
    ]
}
```

### Errors
All the endpoints can return errors in the following format
```json
{
    "message": "The vendor contains errors and cannot not be created.",
    "timestamp": "2024-09-04T02:19:30.883932888",
    "validationErrors": {
        "locationId": "Location not found.",
        "name": "Name cannot be blank."
    }
}
```

# Running the application

## Run on docker
```
docker build -t vs-tech-test .

docker run -dp 127.0.0.1:8000:8000 vs-tech-test 
```

## Run without docker
```
./gradlew run
```

## Run tests
```
./gradlew clean test
```
